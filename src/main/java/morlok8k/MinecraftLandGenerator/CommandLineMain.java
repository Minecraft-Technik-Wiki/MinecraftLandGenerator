package morlok8k.MinecraftLandGenerator;

import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.joml.Vector2i;

import picocli.CommandLine;
import picocli.CommandLine.Command;
import picocli.CommandLine.Help.Visibility;
import picocli.CommandLine.HelpCommand;
import picocli.CommandLine.Option;
import picocli.CommandLine.Parameters;
import picocli.CommandLine.RunLast;

@Command(name = "mlg", subcommands = { HelpCommand.class })

public class CommandLineMain implements Runnable {

	private static Log log = LogFactory.getLog(CommandLineMain.class);

	@Option(names = { "-v", "--verbose" }, description = "Be verbose.")
	private boolean verbose = false;
	@Option(names = { "-r", "--region" }, description = "Regionfiles instead of chunks")
	private boolean regionFile = false;

	@Option(names = { "-s", "--customspawn" }, description = "Customized SpawnPoints")
	private String[] customSpawnPoints;

	@Option(names = "-i", description = "override the iteration spawn offset increment",
			defaultValue = "380", showDefaultValue = CommandLine.Help.Visibility.ALWAYS)
	private int increment = 380;

	@Option(names = { "--x-offset", "-x" },
			description = "set the X offset to generate land around")
	private int xOffset = 0;

	@Option(names = { "--y-offset", "-y" },
			description = "set the Z offset to generate land around")
	private int zOffset = 0;

	@Parameters(index = "0", description = "X-coordinate")
	private int X;

	@Parameters(index = "1", description = "Z-coordinate")
	private int Z;

	@Option(names = { "-s", "--serverFile" }, description = "Path to the server's jar file.",
			defaultValue = "server.jar", showDefaultValue = Visibility.ALWAYS)
	private Path serverFile;

	@Option(names = { "-w", "--worldPath" },
			description = "Path to the world that should be generated. Defaults to the value in server.properties")
	private Path worldPath;

	@Option(names = { "--java-cmd" },
			description = "Java command to launch the server. Defaults to `java -jar`.")
	private String[] javaOpts;

	public CommandLineMain() {

	}

	@Override
	public void run() {
		Server server = new Server(javaOpts, serverFile);
		if (worldPath != null)
			server.setWorld(worldPath);
		else worldPath = server.getWorld();
		if (worldPath == null || !Files.exists(worldPath)) {
			log.warn(
					"No world was specified or the world at the given path does not exist. Starting the server once to create one...");
			server.runMinecraft();
			worldPath = server.getWorld();
		}
		if (worldPath == null || !Files.exists(worldPath)) {
			log.fatal("There is still no world, we cannot continue without world");
			return;
		}
		for (Vector2i spawn : generateSpawnpoints(startX, startZ, width, height, maxInc,
				generationRadius)) {
			server.setSpawn(level, spawn);
			server.runMinecraft();
		}
		server.restoreWorld();
	}

	public static void main(String[] args) {
		CommandLine cli = new CommandLine(new CommandLineMain());
		cli.parseWithHandler(new RunLast(), args);
	}

	/**
	 * @param maxInc
	 *            Maximum number of chunks between two spawn points, horizontally or vertically
	 * @param generationMargin
	 *            The radius to each side that will be generated by the server (Not the diameter!)
	 */
	public static List<Vector2i> generateSpawnpoints(int startX, int startZ, int width, int height,
			int maxInc, int generationRadius) {
		if (width < generationRadius || height < generationRadius)
			throw new IllegalArgumentException("Width and height must both be at least "
					+ (generationRadius * 2 + 1) + ", but are " + width + " and " + height);
		List<Integer> xPoints = generateLinearSpawnpoints(startX + generationRadius,
				width - generationRadius * 2, maxInc);
		List<Integer> zPoints = generateLinearSpawnpoints(startZ + generationRadius,
				height - generationRadius * 2, maxInc);
		List<Vector2i> spawnPoints = new ArrayList<>(xPoints.size() * zPoints.size());
		for (int x : xPoints)
			for (int z : zPoints)
				spawnPoints.add(new Vector2i(x, z));
		return spawnPoints;
	}

	private static List<Integer> generateLinearSpawnpoints(int start, int length, int maxStep) {
		int stepCount = (int) Math.ceil((double) length / maxStep);
		double realStep = length / stepCount;
		return IntStream.range(0, stepCount).mapToObj(i -> start + (int) (realStep * i))
				.collect(Collectors.toList());
	}
}
